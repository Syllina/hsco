考虑如下的数据和类型间的逻辑关系：

第一种表示法：
```haskell
data Arcanist = ThirtySeven | Toothfairy | ...
```

第二种表示法
```haskell
class Arcanist a where
    attrGen :: a -> AttributeGenerator

-- 这里忘记怎么写 type-carried info 了
instance Arcanist ThirtySeven where
    attrGen _ = fromRaw [36, 269, 408, 683, 1019, 1199]
```

第三种表示法
```haskell
newtype ArcID = Int
data Arcanist = Arcanist {
    arcID :: ArcID
}

attrGen :: ArcID -> AttributeGenerator
```

一和三似乎是等价的，给一的 data 加一个 `deriving (Enum)` 就转化为了三，给三加一个 mapping（ThirtySeven = 1 :: ArcID）就转化为了一

也就是信息是存储在 data 中（data constructor 也是 data 的一部分）还是存储在 type 中
如果存储在 type 中，怎么让 Arcanist 成为一个 kind？

类比 oop，大概就是是一个类中存储 id 来标识这是哪一种，还是类继承，在类型中表示这是哪一种

优劣势？先来看一下 hid 中的例子

type system 是为了在编译时刻发现错误设计的. 方案二是否能增加规避的错误量？
支持 aggressive refactoring（因为 refactor 中可能 introduce 的很多错误都会在编译时间规避掉）

考虑摄氏度和华氏度转换的场景.（为什么不使用两个独立的 type？）
`Maybe` 作为一个 kind，是作用在 Type 上的函数.
全部用 `*` 有什么问题？无法将 type class 引入到这个 kind system 中（现在是怎么引入的？Constraint），同时将所有类型都送到 `*` kind 没有区分度（现在是怎么区分的？）
`NoStarIsType` extension
```haskell
Fractional :: Type -> Constraint
```

为什么不能看 `Maybe a` 的类型？因为 a 没有定义，就像一个谓词，不能判断 P(x) 的真假. 打开 `ExplicitForAll` 后，可以判断 `forall a. Maybe a` 的 `kind`.

`kind` 自身也有 kind，从 `Data.Kind` 中引入后，可以看到 `Type` 和 `Constraint` 的 kind 都是 `Type`.
也就是说，Term 的 type 是 Type，type 的 kind 是 type.

没有 term 的 type 有用吗？可以用来做 phantom parameters
应用场景：想要分辨摄氏度和华氏度，但是想用同一个类型，同一种方式存储
```haskell
newtype Temp unit = Temp Double deriving (...)
data F
data C
```
那么 `Temp F` 和 `Temp C` 就是不同的类型，不能被混用，但是它们有同样的存储方式.
缺陷在于可以定义 `Temp Bool` 等无意义的类型.

有些时候这样的类型需要一个无意义的取值.
```haskell
data Proxy t = Proxy
```
可以用 proxy 来定义 `Temp unit` 的 `Show` instance.
为什么不能直接定义？
如果使用 `OverlappingInstances`，应该可以定义这样的实例
```haskell
instance Show (Temp C) where
    show (Temp t) = ...
```

我们实际上可以利用 `Proxy`，对 unit 类型定义 type class，通过 `Proxy` 值的参数来区分返回值，`ScopedTypeVariables` 允许你在函数定义中使用``外部''的类型变量.
```haskell
class UnitName u where
    unitName :: Proxy u -> String
```
这样可以很容易地引入新的单位.
```haskell
instance UnitName K where
    unitName _ = "K"
```

在 type class 定义中的类型变量 u 默认的 kind 为 Type，所以我们不能为其他 kind 的类型定义 instance. `PolyKinds` 扩展可以放松这一限制.

```haskell
read :: (Read a) => String -> a
```
`read` 实际上需要一个类型 a 作为参数，在打开 `TypeApplications` 的情况下，我们可以通过 `read @Int "42"` 来给 a 提供值.
打开这一扩展后，我们可以不使用 `Proxy` 实现 `unitName`，这个时候我们无法得知 `unitName` 的类型（虽然看起来只是返回了 `String`，但是类型 (`UnitName u`) 也是它的一个参数），只有 `unitName @F` 才是一个返回 `String` 的函数.
visible type applications 不能完全取代 proxy.

---

打开 `DataKinds` 扩展后
```haskell
data TempUnits = F | C
```
会同时定义 type/term 和 kind/type，然后就可以如下限制类型变量
```haskell
newtype Temp (u :: TempUnits) = Temp Double
```
编译器会用 `'F` 来表示 `Type`.
在 `GHC.TypeLits` 里，自然数和字符串都是类型，它们对应的 kind 是 `Nat/Symbol`. list 也可以成为 kind.
读取的方法是
```haskell
symbolVal :: forall s. KnownSymbol s => Proxy x -> String
```

---

11.3 Type Families
type 上的映射
type synonym families（不创建新的类型）
data families（可以定义新的数据类型）
associated families（定义在 type class 中）

```haskell
type family Simplify t

type instance Simplify Integer = Integer
type instance Simplify Int = Integer
```

与一般的数据类型类似的是，`Simplify Integer` 确实是一个 type，只不过类似一个 type synonym，实现时可以得到简化

```haskell
type family Widen a where
    Widen Bool = Int
    Widen Int = Integer
    Widen Char = String
    Widen t = String
```

这是 closed type family，可以有 catch-all 的 instance

为了实现实际的函数的重载，我们需要一个 type class 实现功能.

data family：同样的外部表示，不同的内部实现
```haskell
data family XList a
newtype instance XList () = XListUnit Integer
data instance XList Bool = XBits Integer Integer
```
也就是可以把 `XList ()` 看作一个新的类型
然后使用一个 type class 描述一个 `forall a. XList a` 应满足的性质
data family 可以从 data constructor 推断出对应的 type parameter，这是一个单射，这是 type synonym family 没有的特性

---

associated families
场景：将图的接口与它内部的表达方式分离
```haskell
class Graph g where
    type Vertex g
    data Edge g
    src, tgt :: Edge g -> Vertex g
```

与 data family 类似，可以用于分离接口和实现的数据类型

associated family 更常用

---

GADTs

```haskell
data DynValue a where
    S :: String -> DynValue String
    C :: Char -> DynValue Char
    B :: Bool -> DynValue Bool
```

---

首先，上面将 `Arcanist` 作为 type class 有一个明显的问题，即 `Arcanist` 不是一个类型.
一个方法是使用 `DataKinds`
首先定义一个包含所有 arcanists 的数据类型
```haskell
data Arcanist = ThirtySeven | ToothFairy | ...
```

然后使用带 type parameter (`a :: Arcanist`) 的类型来描述 arcanist.
这样的问题在于不能把不同的神秘学家用一个类型来表述
我们可以使用 GADTs 对这样的类型进行包装
```haskell
data SomeArcanist where
    SomeArcanist :: (IsArcanist a) => Arcanist a -> SomeArcanist
```

这里为了避免需要在一个文件中列出所有的神秘学家，尝试不使用 `DataKinds`，而定义一个 `class IsArcanist`，然后在对应描述神秘学家的文件里定义一个空的 data 并实现对应的实例

或许应该选择称为 `IsArcanistType`，然后 `IsArcanist` 用来描述 实例 的属性？能否将 `Arcanist` 和它的 wrapper 都声明成这个实例？

需要解决的问题是，现在有多个具有相同接口（如各种数值，咒语效果等）的不同类型，如何构建一个能够容纳它们的列表.

包括有神秘学家的列表，任何能战斗生物的列表等等.

这个问题被称为 [heterogenous collections](https://wiki.haskell.org/Heterogenous_collections)

其中提到了 [HList-ext.pdf](https://okmij.org/ftp/Haskell/HList-ext.pdf)

暂时感觉这个解法没有直接使用 existential types 方便？

---

如何描述共鸣？

主模块类型决定：
神秘学家类型到对应的共鸣主模块（作为被 `DataKinds` promote 的 type）的映射可以表示为一个 associated type family
```haskell
class IsArcanist arc where
    type ArcResType arc
```

但是由 DataKinds 产生的的类型并不是 Type kind 的，而是一个新的 type. 这时候改用如下代码居然神奇地通过了编译！
```haskell
data ResonanceType = X | T | Z | U
class IsArcanist arc where
    type ArcResType arc :: ResonanceType
```

主模块 + 等级决定的模块类型、数量、大小和格子大小

主模块放在类型中，等级和摆放类型作为变量. 这样的话在创建共鸣时必须给定一个摆放方案（其实也是合理的，默认是空）

如何表示摆放方案？能摆放的模块与共鸣等级 / 主模块类型有关. 暂时先用一个 list 代替？或者可以只给定 list，check 能否满足条件？（这是一个静态问题，可以预先计算）

如何表示属性？检查可行性时只需要考虑类型和数量即可，属性可在最后计算.

描述共鸣就不使用 type system 检验可行性了（也不知道应该怎么做），使用运行时检查.

计算共鸣属性时需要知道角色类型和等级（满级属性决定主模块加成，基础面板决定百分比加值的实际效果），计算得到的属性如何表示？现在只能把一个类型声明为 HasStat，如何表示心相和 buff 等的百分比属性加成？

尝试设计 `HasStatBuff` 的 type class，或者设计成数据类型更好？

将 `Stat` 和 `StatMod` 改成了数据类型，对于四个本身为 `Int` 的属性，有具体数字的加值（心相、共鸣主模块）和百分比加值两种，在同时有这两种时先应用百分比（然后取整），再应用具体数字加值.

尝试通过编译时遇到了新的问题.

现在由于 `Arcanist` 的类型被写在了类型里，描述某个神秘学家的共鸣类型就需要建立一个类型到类型的映射，这里使用的是 associated type family，对于某个 "满足作为神秘学家的条件" 的类型 `arc`，`ArcResType arc` 是它的共鸣主类型.

而共鸣主类型属于 kind `ResonanceType`，描述共鸣类型的属性写在 type class `IsResonanceType` 中. 主模块类型是不需要后续添加的（这一点被 `DataKinds` 定死了），然而 type class 是一个可以随时追加实现的模式，这是第一个问题.

第二个问题是 associated type family 是写在 `IsArcanist arc` 中的，这里限定了共鸣的 kind，但没有限定它的 type class，导致之后写 instance 时不仅要给出 `IsAcanist arc` 的限制，还需要给出 `IsResonanceType (ArcResType arc)` 的限制，后者不能直接通过编译，需要开启 `FlexibleContexts` 和 `UndecidableInstances` 两个扩展才能通过编译（并且这样一个限制还需要写两遍）.

（其实这样能过编译就很厉害了（可能是扩展导致的？），因为 `ArcResType` 依赖于 `IsArcanist` 的 instance，而这两个限制在这里是并列的）

有没有办法能将某一个 kind 下的所有 type 都声明成某个 type class 的 instance，或者给 associated type family 加入 instance 的限制？

现在暂时使用 `ConstraintKinds` 扩展，将这些限制合并为一个限制.

---

心相的表示采用了和神秘学家定义相似的方法，但是目前需要在导出列表中枚举每个心相.

之后可能需要得到所有神秘学家的列表（例：选择角色，或从名字等反求），是否还是需要一个列表？考虑自动生成？

---

## 伤害计算公式的推理

已知的部分：

> 理论伤害 = 攻防项 * 增伤项 * 威力项 * 暴击项 * 属性克制 * 技能倍率
>     攻防项 = 攻击方面板攻击 * (1 + 攻击提升) - 受击方对应面板防御 * (1 + 防御提升 - 防御降低) * (1 - 攻击方穿透率)
>         面板攻击 = 自带攻击 * (1 + 共鸣百分比 + 心相百分比) + 共鸣固定 + 心相固定
>         该项与 攻击方面板攻击 * (1 + 攻击提升) * 10% 取 max
>     增伤项 = 1 + 攻击方创伤加成 - 受击方受创减免
>         下限为 0.3
>     威力项 = 1 + 攻击方术法威力/仪式威力
>     暴击项 = 1 + 攻击方暴击创伤 - 受击方暴击防御
>         下限为 1.1
>
> 本源创伤 = 面板攻击 * (1 + 攻击提升) * 技能倍率

需要解决：
- [ ] 在哪里取整？
    - [ ] 生命 / 伤害 / 防御 等本身整数表示的部分
    - [ ] 创伤加成等游戏内显示为一位小数的部分（是否是小数点后一位取整）
    - [ ] 伤害计算公式中间值
    - [ ] 技能描述中不符合理论比率 2:3:5 的
    - [ ] 多段伤害会导致总伤变化吗

首先进行一些漫无目的的实验.

参与测试的人员有：

> 37（攻击: 2042, 现防: 860, 精防: 925, 暴击创伤: 186.8%+15%=201.8%, 创伤加成: 10%, 受创减免: 10%）
> 三角正论：140%/210%/350% 精神 + 40%/60%/100% 本源
> 曲线映射： 70%/105%/175% 精神 + 40%/60%/100% 本源（37 的精神部分群攻正好是单体的一半欸）
> 补充算式：240% 精神 + 80% 本源
>
> 数维的感知：攻击提升 10%
> 启迪：本源威力 +100%
> 沉默与向往：额外行动创伤加成 +12%；额外行动本源威力 +50%

> 洁西卡（攻击: 1889, 现防: 888, 精防: 888, 暴击创伤: 149.3%, 暴击防御: 4%, 创伤加成: 27%+8%(+20%, 中毒), 受创减免: 5%, 术法威力：18%）
> 白绒毯：(180%+40%+20%+20%)*[1, 1.5, 2.5] 现实
> 好朋友：135%+30% / 200%+45% / 335%+75% 现实
> 凝视来自深林之中：425% 现实
> 中毒：30% 本源
>
> 夜色亵渎者：创伤加成 +24%

> 梅兰妮（攻击: 1744, 现防: 842, 精防: 842, 暴击创伤: 153.1%, 创伤加成: 15.5%+8%, 受创减免: 11%, 仪式威力: 18%）
> 乘隙而入：200%/250%/400% 精神
> 发条鼠患：120%/180%/300% 精神
> 荒唐的目击证词：650% 精神
>
> 既定计划：仪式威力 +12%
> 大娱乐至上：仪式后创伤加成 +9%

> 未锈铠（攻击: 1535, 现防: 714, 精防: 714, 暴击创伤: 149.1%, 创伤加成: 8%, 受创减免: 7%+8%, 仪式威力: 18%）
> 公义：180%/250%/450% 现实
> 荣耀：150%/150%/225% 现实
> 公元七七八年后：500% 现实
>
> 怜悯：敌方每损失 20% 的生命，创伤加成与穿透率 +10%
> 请保持平衡：若无克制，创伤加成 +12%

```
实验一：4th-21 好天气 厄险
回合一：
37 三角正论：728+728+2185 + 1503 = 3641 + 1503 = 5144（暴击）
37 曲线映射：910+910 + 1503 = 1820 + 1503 = 3323（暴击）
小鹿 白绒毯：4832 = 4832
小鹿 白绒毯：6364 = 6364（暴击）
小鹿 好朋友：906+906+906+906 = 3624
小鹿 好朋友：1193+1194+1193+1193 = 4773（暴击）
小鹿 中毒：566
梅兰妮 乘隙而入：514+772+1286 = 2572
梅兰妮 乘隙而入：697+1046+1742 = 3485（暴击）
梅兰妮 发条鼠患：617+309+308+309 = 1543
梅兰妮 发条鼠患：836+419+418+418 = 2091（暴击）
未锈铠 公义：637+637+850 = 2124（克制）
未锈铠 公义：838+838+1117 = 2793（克制，暴击）
未锈铠 荣耀：1770 = 1770（克制）
未锈铠 荣耀：2328 = 2328（克制，暴击）

首先考虑暴击创伤.
小梅的暴击创伤近似为 135.5%
未锈铠的近似为 131.5%
小鹿的近似为 131.7%（小鹿这个两个技能一模一样）
假设对方的暴击防御为 17.6%

小鹿的毒伤是 30% 的攻击，大约是 566.7，但实际的数值是 566，初步判断这一步是直接取整.
回合二（一层梦境干扰 创伤加成 -2%）：
37 三角正论：713+713+2139 + 1503 = 3565 + 1503 = 5068（暴击）
37 曲线映射：891+891 + 1503 = 1782 + 1503 = 3285（暴击）
小鹿 白绒毯：4763 = 4763
小鹿 白绒毯：6274 = 6274（暴击）
小鹿 好朋友：893+893+893+893 = 3572
小鹿 好朋友：1176+1177+1176+1176 = 4705（暴击）
梅兰妮 乘隙而入：505+758+1262 = 2525
梅兰妮 发条鼠患：821+410+411+410 = 2052（暴击）

先考虑小鹿单体未暴击的情况. 解如下方程
A(1+x) = 4832
A(1+x-0.02) = 4763
得到 A=3450, x=40.05%
暴击情况为
B(1+x) = 6364
B(1+x-0.02) = 6274
B=4500, x=41.42%

同样对群体解方程得
A=2600, x=39.38%
B=3400, x=40.38%

为什么不一样？我们换上十四行诗.
小鹿 白绒毯：5348 7044（暴击）/ 5279 6953（暴击）
A=3450, x=55.01%
B=4550, x=54.81%

很明显，这是因为解方程的时候除以 0.02 的操作的精度没有保证.
不论最后的 A 值是多少，作差后除以 0.02 后一定是 50 的倍数.
4832/3425 - 4832/3475 = 0.02
也就是 A 值一定会有 50 的误差，随之也会带来 x 的 2% 的（绝对）误差.

我们先处理一个不那么棘手的情况，即本源伤害部分.
小鹿的毒伤只有两个变量，即基础攻击和本源倍率（实际上还有肉鸽可能的本源威力项？）
而 37 的本源伤害受到攻击数值、倍率、暴击项的三重影响.
首先假设攻击数值为整数、暴击项保留到百分号小数点后一位，探究它们的取整顺序.
攻击: 2042
暴击项: 201.8% - 17.6% = 184.2%（暂且认为 17.6% 是准确的）
倍率: 40%
2042 * 184.2% * 40% = 1504.5
而实测得到的数值是 1503
floor(2042 * 184.2%) * 40% = 1504.4
floor(2042 * 40%) * 184.2% = 1503.1
[ 40% * 184.2% = 0.7368 => 0.736; 2042 * 0.736 = 1502.9 => 1503 ]
基于中间变量取整的假设，我们认为是攻击先乘上技能倍率后取整再乘上了暴击项.

攻防 * 倍率 * 暴击
攻防 * 倍率 * 增伤 [* 暴击]
不带夜色的小鹿
攻击 1529
增伤 27%+8%+20%
倍率 220%（一层中毒）
1t 单体 2982/3301 群体 2237/2475
2t 单体 2940/3258 群体 2205/2444
尝试找到这样的一个整数 A 和浮点数 x（精度见上），使得
A*2.20*(1+x) = 2982, A*2.20*(1+x+0.15) = 3301
A*1.65*(1+x) = 2237, A*1.65*(1+x+0.15) = 2475
A*2.20*(1+x-0.02)=2940, A*2.20*(1+x+0.15-0.02) = 3258
A*1.65*(1+x-0.02)=2205, A*1.65*(1+x+0.15-0.02) = 2444

如果是在攻防乘倍率之后取整，则找不到满足条件的解；如果是三项全部相乘之后取整，则 A=965, x=0.405 满足条件.
验证：
3t 单体 3161/3508 群体 2173/
4t 单体 2855/ 群体 2141/ 仪式 5516/
均满足条件.（这里 4t 的时候十四行诗的 buff 被驱散了！）
那么对方的防御为 1529-965=564，创伤减免为 155%-140.5%=14.5%

2572 1543

初步怀疑是先计算原本的伤害，取整后依据是否暴击计算暴击的伤害.
直接乘上术法威力后发现结论仍然成立
例：带十四行诗的小鹿第二回合单体
(1889-564)*2.20*(1+0.27+0.08+0.2-0.145+0.15-0.02)*1.18 = 5279.9395
实际伤害为 5279.

接下来还需要验证暴击（是否是取整后再乘）/ 属性克制 / 攻防项内部
发现除了 37，所有人将暴击直接相乘后最后取整得到的结果正确.
（所以其实一开始直接代公式就是对的... 但是 37 你怎么了）

测试 37 带不同心相和去掉一个只影响攻击的共鸣块造成的暴击本源创伤
对每个心相测试是否有牙仙被动

1607 151.8%
1248+642=1890
1863+958=2821
624+642=1266
931+958=1889

漫长悄悄话 (1958 => 1442.6544 / 1560.1344)
4053+1443=5496
2026+1443=3469

沉默与向往 (2042 => 1504.5456 / 1627.0656)
1503/5144 [-1.5]
1626/5564 [-1.0]

必要的记录 (1988 => 1464.7584 / 1584.0384)
1465/5414 [+0.2]
1584/5855 [-0.0]

大娱乐至上（1958 => 1442.6544 / 1560.1344)
1443/4877 [+0.4]
1560/5274 [-0.1]

漫长悄悄话 (1958 => 1442.6544 / 1560.1344)
1443/5496 [+0.4]
1560/5943 [-0.1]

在四方城外 (1948 => 1435.2864 / 1552.1664)
1435/4845 [-0.3]
1552/5239 [-0.2]

美丽新世界 (1948 => 1435.2864 / 1552.1664)
1435/4845 [-0.3]
1552/5239 [-0.2]

第二次生命 (1945 => 1433.0760 / 1549.7760)
1433/4835 [-0.1]
1550/5229 [+0.2]

夜色亵渎者 (1938 => 1427.9184 / 1544.1984)
1428/5423 [+0.1]
1544/5864 [-0.2]

在仙境之外 (1928 => 1420.5504 / 1536.2304)
1420/4781 [-0.6]
1536/5170 [-0.2]

请保持平衡 (1918 => 1413.1824 / 1528.2624)
1413/4958 [-0.2]
1528/5362 [-0.3]

掌声如雷鸣 (1908 => 1405.8144 / 1520.2944)
1406/5077 1406/3061 [+0.2]
1520/5460 1520/3310 [-0.3]

此刻无新事 (1870 => 1377.8160 / 1490.0160)
1378/5110 [+0.2]
1490/5526 [-0.0]

掌声如雷鸣 (1868 => 1376.3424 / 1488.4224)
1376/4937 [-0.3]
1488/5311 [-0.4]

好奇心宝贝 (1862 => 1371.9216 / 1483.6416)
1371/4569 [-0.9]
1482/4940 [-1.6]

可度量之心 (1846 => 1360.1328 / 1470.8928)
1360/4518 [-0.1]
1470/4886 [+0.1]

好奇心宝贝（1822 => 1342.4496 / 1451.7696)
1341/4440 [-1.4]
1450/4802 [-1.8]

心驰神往 (1821 => 1341.7128 / 1450.9728)
1341/5499 [-0.7]
1450/5947 [-1.0]

无拘无束 (1697 => 1250.3496 / 1352.1696)
1249/4274 [-1.3]
1351/4622 [-1.2]

笑语欢声 (1696 => 1249.6128 / 1351.3728)
1249/4038 [-0.6]
1351/4367 [-0.4]

无拘无束 (1657 => 1220.8776 / 1320.2976)
1220/4138
1319/4475

笑语欢声 (1656 => 1220.1408 / 1319.5008)
1220/3910
1319/4228

跳房子游戏 (1640 => 1208.3520 / 1306.7520)
1209/4178 [+0.6]
1307/4518 [+0.2]

无心相 (1578 => 1162.6704 / 1257.3504)
1162/3660 [-0.7]
1257/3958 [-0.4]

爱兹拉 (1673.406)
1258 1674

37 + 牙仙 (1627.0656)
1626/5564

爱兹拉 (1673.406 / 1862.136)
1674/1863

爱兹拉 无心相（995.505 / 1107.78)
995/1107

不暴击的本源创伤似乎是符合直接下取整的，并且是精神和本源部分分别下取整

测试一下新巴别塔的现实暴击本源不暴击的情况
攻击 987 现防 523 暴击创伤 146.8% 创伤加成 0.5%
436+418=854（不暴击）
629+418=1047（暴击）
一层 debuff 且 无牙仙 且 现实防御 +5%
现实防御 549
426+439=865（不暴击）
551+439=990（暴击）
两层 debuff 且 现实防御 +5%
现实防御 549
538+439=977（暴击）
两层 debuff
416+418=834（不暴击）
三层 debuff 且 现防 +5%
406+439=845
四层 debuff 且 现防 +5%
439/950

暴击的伤害同样不符合下取整规律（也不符合四舍五入）

所以目前的问题是攻击附带本源伤害的角色在暴击时伤害会不符合计算出的结果.
对于 37 而言，在暴击创伤一定的情况下，本源创伤似乎只跟攻击相关（也就是跟术法威力等等无关？使用 6 和十四行诗测试后发现与穿透率、术法威力和创伤加成应当无关. ）
那么参数就只有 攻击 暴击创伤 倍率
攻击 2042，暴击创伤 184.2%
调整倍率
0.4 0.6 1.0
1503 2257 3763
1504.5 2256.8 3761.4

难道是暴击创伤应当为 184.3%，然后攻击乘倍率先取整？
哇，全部符合！
精神伤害似乎是不取整，但是暴击创伤改为 184.3%
塔姐目前测出的数据也符合这一规律. 蘑菇由于伤害太少没有差别.

换个关卡试一试.
5th20
小鹿群体 3044 单体 4059
小梅群体 1225 单体 2043
铠子群体 1209
双防 567 创伤减免 36.7% 暴击防御 20.1%

沼泽的大象
小鹿单体暴击 10504
小鹿群攻 5463
小梅单体 5696
小梅群攻 3417
小鹿无心相单体 4628
小鹿无心相群攻暴击 5006
牙仙 debuff 3516

现防 450, 精防 350, 创伤减免 0%, 暴击防御 20.0%（对无本源 20.1%）
```

目前的结论是
- 一般攻击所造成的伤害是所有项浮点相乘后取整
- 不带本源附伤的角色暴击创伤降低 0.1%
- 37 的本源暴击伤害先计算非暴击伤害，取整后乘上暴击项再取整
